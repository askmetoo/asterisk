Index: asterisk-14.4.0-rc1/apps/app_queue.c
===================================================================
--- asterisk-14.4.0-rc1.orig/apps/app_queue.c
+++ asterisk-14.4.0-rc1/apps/app_queue.c
@@ -1349,6 +1349,8 @@ enum queue_reload_mask {
 	QUEUE_RELOAD_MEMBER = (1 << 1),
 	QUEUE_RELOAD_RULES = (1 << 2),
 	QUEUE_RESET_STATS = (1 << 3),
+	QUEUE_RELOAD_SKILLS = (1 << 4),
+	QUEUE_RELOAD_SKILL_RULES = (1 << 5),
 };
 
 static const struct strategy {
@@ -1507,9 +1509,14 @@ struct callattempt {
 	char *orig_chan_name;
 };
 
+struct virtual_queue {
+	char id[80];                        /*!< Argument 'ruleset' to the Queue() app. */
+	int holdtime;                       /*!< Estimated Waiting Time for this virtual queue. */
+};
 
 struct queue_ent {
 	struct call_queue *parent;             /*!< What queue is our parent */
+	struct virtual_queue *vqueue;          /*!< Virtual queue in case there is skills routing */
 	char moh[MAX_MUSICCLASS];              /*!< Name of musiconhold to be used */
 	char announce[PATH_MAX];               /*!< Announcement to play for member when call is answered */
 	char context[AST_MAX_CONTEXT];         /*!< Context when user exits queue */
@@ -1529,8 +1536,11 @@ struct queue_ent {
 	int min_penalty;                       /*!< Limit the members that can take this call to this penalty or higher */
 	int linpos;                            /*!< If using linear strategy, what position are we at? */
 	int linwrapped;                        /*!< Is the linpos wrapped? */
+	char skill_ruleset[80];                /*!< Name of the skill ruleset */
+	time_t skills_next_check;              /*!< Next check of skills rules. */
 	time_t start;                          /*!< When we started holding */
 	time_t expire;                         /*!< When this entry should expire (time out of queue) */
+	struct ao2_container *mem_selection;   /*!< Members who match skill rules. */
 	int cancel_answered_elsewhere;         /*!< Whether we should force the CAE flag on this call (C) option*/
 	struct ast_channel *chan;              /*!< Our channel */
 	AST_LIST_HEAD_NOLOCK(,penalty_rule) qe_rules; /*!< Local copy of the queue's penalty rules */
@@ -1538,12 +1548,96 @@ struct queue_ent {
 	struct queue_ent *next;                /*!< The next queue entry */
 };
 
+enum skill_rule_operand_type {
+	SKILL_RULE_OPERAND_VARIABLE,
+	SKILL_RULE_OPERAND_VALUE,
+	SKILL_RULE_OPERAND_OPERATOR,
+};
+
+struct skill_rule_operand {
+	union {
+		char var[80];
+		int value;
+		struct skill_rule_operator* operator;
+	} u;
+	enum skill_rule_operand_type type;
+	AST_LIST_ENTRY(skill_rule_operand) entry;
+};
+
+enum skill_rule_operator_type {
+	SKILL_RULE_OPERATOR_UNKNOWN,
+	SKILL_RULE_OPERATOR_NOTEQUAL,       /*!<  op1 ! op2  */
+	SKILL_RULE_OPERATOR_EQUAL,          /*!<  op1 = op2  */
+	SKILL_RULE_OPERATOR_GREATER,        /*!<  op1 > op2  */
+	SKILL_RULE_OPERATOR_LESSER,         /*!<  op1 < op2  */
+	SKILL_RULE_OPERATOR_AND,            /*!<  op1 & op2  */
+	SKILL_RULE_OPERATOR_OR              /*!<  op1 | op2  */
+};
+
+#define SKILL_RULE_OPERATORS_CHARS "!=><&|"
+static enum skill_rule_operator_type skill_rule_operator_type_str[] = {
+	['!'] = SKILL_RULE_OPERATOR_NOTEQUAL,
+	['='] = SKILL_RULE_OPERATOR_EQUAL,
+	['>'] = SKILL_RULE_OPERATOR_GREATER,
+	['<'] = SKILL_RULE_OPERATOR_LESSER,
+	['&'] = SKILL_RULE_OPERATOR_AND,
+	['|'] = SKILL_RULE_OPERATOR_OR,
+};
+
+/*
+ * When evaluating an operator or getting the value from a variable, the value is either:
+ * - undefined, and the value field must be ignored
+ * - defined, and the value field can be used
+ */
+struct op_value {
+	int defined;
+	int value;
+};
+
+struct skill_rule_operator {
+	struct skill_rule_operator *parent;
+	AST_LIST_HEAD_NOLOCK(,skill_rule_operand) operands;
+	enum skill_rule_operator_type type;
+};
+
+struct skill_rule {
+	struct skill_rule_operator *dcond;           /*!< Condition against dynamical variables */
+	struct skill_rule_operator *cond;            /*!< Condition against skills */
+};
+
+struct skill_ruleset {
+	char name[80];
+	struct ao2_container *rules;
+	AST_LIST_ENTRY(skill_ruleset) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skill_rulesets, skill_ruleset);
+
+struct rule_var {
+	char name[80];
+	char value[80];
+};
+
+struct skill {
+	char name[80];                      /*!< Name of skill */
+	int weight;                         /*!< Weight */
+};
+
+struct skills_group {
+	char name[80];
+	struct ao2_container *skills;       /*!< Head of the list of skills */
+	AST_LIST_ENTRY(skills_group) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skills_groups, skills_group);
+
 struct member {
 	char interface[AST_CHANNEL_NAME];    /*!< Technology/Location to dial to reach this member*/
 	char state_exten[AST_MAX_EXTENSION]; /*!< Extension to get state from (if using hint) */
 	char state_context[AST_MAX_CONTEXT]; /*!< Context to use when getting state (if using hint) */
 	char state_interface[AST_CHANNEL_NAME]; /*!< Technology/Location from which to read devicestate changes */
 	char membername[80];                 /*!< Member name to use in queue logs */
+	char skills[80];                     /*!< Member skills */
 	int penalty;                         /*!< Are we a last resort? */
 	int calls;                           /*!< Number of calls serviced by this member */
 	int dynamic;                         /*!< Are we dynamically added? */
@@ -1552,6 +1646,7 @@ struct member {
 	int paused;                          /*!< Are we paused (not accepting calls)? */
 	char reason_paused[80];              /*!< Reason of paused if member is paused */
 	int queuepos;                        /*!< In what order (pertains to certain strategies) should this member be called? */
+	int holdtime;                        /*!< Average holdtime. */
 	time_t lastcall;                     /*!< When last successful call was hungup */
 	time_t lastpause;                    /*!< When started the last pause */
 	unsigned int in_call:1;              /*!< True if member is still in call. (so lastcall is not actual) */
@@ -1691,6 +1786,7 @@ struct call_queue {
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
 
+	struct ao2_container *vqueues;      /*!< Virtual queues */
 	struct ao2_container *members;      /*!< Head of the list of members */
 	struct queue_ent *head;             /*!< Head of the list of callers */
 	AST_LIST_ENTRY(call_queue) list;    /*!< Next call queue */
@@ -1710,6 +1806,8 @@ static struct ao2_container *queues;
 static void update_realtime_members(struct call_queue *q);
 static struct member *interface_exists(struct call_queue *q, const char *interface);
 static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused);
+static int update_queue_ent_skills_next_check(struct call_queue *q);
+static int member_is_selected(struct queue_ent *qe, struct member *mem);
 
 static struct member *find_member_by_queuename_and_interface(const char *queuename, const char *interface);
 /*! \brief sets the QUEUESTATUS channel variable */
@@ -2191,7 +2289,7 @@ static void queue_publish_member_blob(st
 
 static struct ast_json *queue_member_blob_create(struct call_queue *q, struct member *mem)
 {
-	return ast_json_pack("{s: s, s: s, s: s, s: s, s: s, s: i, s: i, s: i, s: i, s: i, s: i, s: i, s: s, s: i}",
+	return ast_json_pack("{s: s, s: s, s: s, s: s, s: s, s: i, s: i, s: i, s: i, s: i, s: i, s: i, s: s, s: i, s: s}",
 		"Queue", q->name,
 		"MemberName", mem->membername,
 		"Interface", mem->interface,
@@ -2205,7 +2303,8 @@ static struct ast_json *queue_member_blo
 		"Status", mem->status,
 		"Paused", mem->paused,
 		"PausedReason", mem->reason_paused,
-		"Ringinuse", mem->ringinuse);
+		"Ringinuse", mem->ringinuse,
+		"Skills", mem->skills);
 }
 
 /*! \brief Check if members are available
@@ -2214,7 +2313,8 @@ static struct ast_json *queue_member_blo
  * is available, the function immediately returns 0. If no members are available,
  * then -1 is returned.
  */
-static int get_member_status(struct call_queue *q, int max_penalty, int min_penalty, enum empty_conditions conditions, int devstate)
+
+static int get_member_status(struct call_queue *q, int max_penalty, int min_penalty, enum empty_conditions conditions, int devstate, struct queue_ent* qe)
 {
 	struct member *member;
 	struct ao2_iterator mem_iter;
@@ -2229,6 +2329,11 @@ static int get_member_status(struct call
 			}
 		}
 
+		if (qe && !member_is_selected(qe, member)) {
+			ast_debug(4, "%s is unavailable because it is not selected by rule '%s'\n", member->membername, qe->skill_ruleset);
+			continue;
+		}
+
 		switch (devstate ? ast_device_state(member->state_interface) : member->status) {
 		case AST_DEVICE_INVALID:
 			if (conditions & QUEUE_EMPTY_INVALID) {
@@ -2287,7 +2392,7 @@ static int get_member_status(struct call
 
 	if (!devstate && (conditions & QUEUE_EMPTY_RINGING)) {
 		/* member state still may be RINGING due to lag in event message - check again with device state */
-		return get_member_status(q, max_penalty, min_penalty, conditions, 1);
+		return get_member_status(q, max_penalty, min_penalty, conditions, 1, qe);
 	}
 	return -1;
 }
@@ -2376,6 +2481,7 @@ static void update_status(struct call_qu
 		pending_members_remove(m);
 	}
 
+	update_queue_ent_skills_next_check(q);
 	queue_publish_member_blob(queue_member_status_type(), queue_member_blob_create(q, m));
 }
 
@@ -2385,7 +2491,7 @@ static void update_status(struct call_qu
  * \retval 1 if the member is available
  * \retval 0 if the member is not available
  */
-static int is_member_available(struct call_queue *q, struct member *mem)
+static int is_member_available(struct call_queue *q, struct member *mem, struct queue_ent *qe)
 {
 	int available = 0;
 
@@ -2404,7 +2510,8 @@ static int is_member_available(struct ca
 			/* else fall through */
 		case AST_DEVICE_NOT_INUSE:
 		case AST_DEVICE_UNKNOWN:
-			if (!mem->paused) {
+			if (!mem->paused &&
+			    (!qe || member_is_selected(qe, mem))) {
 				available = 1;
 			}
 			break;
@@ -2467,7 +2574,7 @@ static void device_state_cb(void *unused
 
 			/* check every member until we find one NOT_INUSE */
 			if (!avail) {
-				avail = is_member_available(q, m);
+				avail = is_member_available(q, m, NULL);
 			}
 			if (avail && found_member) {
 				/* early exit as we've found an available member and the member of interest */
@@ -2589,7 +2696,7 @@ static int get_queue_member_status(struc
 }
 
 /*! \brief allocate space for new queue member and set fields based on parameters passed */
-static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int ringinuse)
+static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int ringinuse, const char *skills)
 {
 	struct member *cur;
 
@@ -2622,6 +2729,10 @@ static struct member *create_queue_membe
 			ast_copy_string(cur->state_context, S_OR(context, "default"), sizeof(cur->state_context));
 		}
 		cur->status = get_queue_member_status(cur);
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(cur->skills, skills, sizeof(cur->skills));
+		else
+			cur->skills[0] = '\0';
 	}
 
 	return cur;
@@ -3274,6 +3385,7 @@ static void rt_handle_member_record(stru
 	const char *state_interface = S_OR(ast_variable_retrieve(member_config, category, "state_interface"), interface);
 	const char *penalty_str = ast_variable_retrieve(member_config, category, "penalty");
 	const char *paused_str = ast_variable_retrieve(member_config, category, "paused");
+  const char *skills_str = ast_variable_retrieve(member_config, interface, "skills");
 
 	if (ast_strlen_zero(rt_uniqueid)) {
 		ast_log(LOG_WARNING, "Realtime field uniqueid is empty for member %s\n", S_OR(membername, "NULL"));
@@ -3321,9 +3433,15 @@ static void rt_handle_member_record(stru
 				ast_copy_string(m->state_interface, state_interface, sizeof(m->state_interface));
 			}
 			m->penalty = penalty;
+			if (!ast_strlen_zero(skills_str)) {
+				ast_copy_string(m->skills, skills_str, sizeof(m->skills));
+			} else {
+				m->skills[0] = '\0';
+			}
 			m->ringinuse = ringinuse;
 			found = 1;
 			ao2_ref(m, -1);
+			update_queue_ent_skills_next_check(q);
 			break;
 		}
 		ao2_ref(m, -1);
@@ -3332,9 +3450,10 @@ static void rt_handle_member_record(stru
 
 	/* Create a new member */
 	if (!found) {
-		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, ringinuse))) {
+		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, ringinuse, skills_str))) {
 			m->dead = 0;
 			m->realtime = 1;
+			update_queue_ent_skills_next_check(q);
 			ast_copy_string(m->rt_uniqueid, rt_uniqueid, sizeof(m->rt_uniqueid));
 			if (!log_membername_as_agent) {
 				ast_queue_log(q->name, "REALTIME", m->interface, "ADDMEMBER", "%s", paused ? "PAUSED" : "");
@@ -3378,6 +3497,10 @@ static void destroy_queue(void *obj)
 		}
 	}
 	ao2_ref(q->members, -1);
+
+	if (q->vqueues) {
+		ao2_ref(q->vqueues, -1);
+	}
 }
 
 static struct call_queue *alloc_queue(const char *queuename)
@@ -3694,7 +3817,8 @@ static int join_queue(char *queuename, s
 	/* This is our one */
 	if (q->joinempty) {
 		int status = 0;
-		if ((status = get_member_status(q, qe->max_penalty, qe->min_penalty, q->joinempty, 0))) {
+		/* do not give 'qe' because the members selection isn't made yet. */
+		if ((status = get_member_status(q, qe->max_penalty, qe->min_penalty, q->joinempty, 0, NULL))) {
 			*reason = QUEUE_JOINEMPTY;
 			ao2_unlock(q);
 			queue_t_unref(q, "Done with realtime queue");
@@ -3711,6 +3835,10 @@ static int join_queue(char *queuename, s
 		 * Take into account the priority of the calling user */
 		inserted = 0;
 		prev = NULL;
+
+		if (!ast_strlen_zero(qe->skill_ruleset))
+			join_virtual_queue(q, qe);
+
 		cur = q->head;
 		while (cur) {
 			/* We have higher priority than the current user, enter
@@ -3743,6 +3871,7 @@ static int join_queue(char *queuename, s
 		ast_copy_string(qe->announce, q->announce, sizeof(qe->announce));
 		ast_copy_string(qe->context, q->context, sizeof(qe->context));
 		q->count++;
+		update_queue_ent_skills_next_check(q);
 		if (q->count == 1) {
 			ast_devstate_changed(AST_DEVICE_RINGING, AST_DEVSTATE_CACHABLE, "Queue:%s", q->name);
 		}
@@ -3828,7 +3957,7 @@ static int valid_exit(struct queue_ent *
 
 static int say_position(struct queue_ent *qe, int ringing)
 {
-	int res = 0, announceposition = 0;
+	int res = 0, announceposition = 0, holdtime;
 	long avgholdmins, avgholdsecs;
 	int say_thanks = 1;
 	time_t now;
@@ -3903,11 +4032,12 @@ static int say_position(struct queue_ent
 		}
 	}
 	/* Round hold time to nearest minute */
-	avgholdmins = labs(((qe->parent->holdtime + 30) - (now - qe->start)) / 60);
+	holdtime = get_estimated_waiting_time(qe);
+	avgholdmins = labs(((holdtime + 30) - (now - qe->start)) / 60);
 
 	/* If they have specified a rounding then round the seconds as well */
 	if (qe->parent->roundingseconds) {
-		avgholdsecs = (labs(((qe->parent->holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
+		avgholdsecs = (labs(((holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
 		avgholdsecs *= qe->parent->roundingseconds;
 	} else {
 		avgholdsecs = 0;
@@ -3987,6 +4117,13 @@ playout:
 	return res;
 }
 
+static void recalc_member_holdtime(struct member *mem, int newholdtime)
+{
+	int oldvalue;
+	oldvalue = mem->holdtime;
+	mem->holdtime = (((oldvalue << 2) - oldvalue) + newholdtime) >> 2;
+}
+
 static void recalc_holdtime(struct queue_ent *qe, int newholdtime)
 {
 	int oldvalue;
@@ -4025,6 +4162,8 @@ static void leave_queue(struct queue_ent
 			RAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);
 			char posstr[20];
 			q->count--;
+			update_queue_ent_skills_next_check(q);
+
 			if (!q->count) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s", q->name);
 			}
@@ -4143,9 +4282,10 @@ static void hangupcalls(struct queue_ent
  * \note The queue passed in should be locked prior to this function call
  *
  * \param[in] q The queue for which we are couting the number of available members
+ * \param[in] qe The queue entry for which we are counting the number of available associated members (can be NULL).
  * \return Return the number of available members in queue q
  */
-static int num_available_members(struct call_queue *q)
+static int num_available_members(struct call_queue *q, struct queue_ent *qe)
 {
 	struct member *mem;
 	int avl = 0;
@@ -4154,7 +4294,7 @@ static int num_available_members(struct
 	mem_iter = ao2_iterator_init(q->members, 0);
 	while ((mem = ao2_iterator_next(&mem_iter))) {
 
-		avl += is_member_available(q, mem);
+		avl += is_member_available(q, mem, qe);
 		ao2_ref(mem, -1);
 
 		/* If autofill is not enabled or if the queue's strategy is ringall, then
@@ -4195,7 +4335,7 @@ static int compare_weight(struct call_qu
 		if (q->count && q->members) {
 			if ((mem = ao2_find(q->members, member, OBJ_POINTER))) {
 				ast_debug(1, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
-				if (q->weight > rq->weight && q->count >= num_available_members(q)) {
+				if (q->weight > rq->weight && q->count >= num_available_members(q, NULL)) {
 					ast_debug(1, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
 					found = 1;
 				}
@@ -4243,7 +4383,7 @@ static int member_status_available(int s
  *
  * \retval non-zero if an entry can be called.
  */
-static int can_ring_entry(struct queue_ent *qe, struct callattempt *call)
+static int can_ring_entry(struct queue_ent *qe, struct callattempt *call, int *busies)
 {
 	if (call->member->paused) {
 		ast_debug(1, "%s paused, can't receive call\n", call->interface);
@@ -4269,6 +4409,13 @@ static int can_ring_entry(struct queue_e
 		return 0;
 	}
 
+	if (!member_is_selected(qe, call->member)) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "%s doesn't match ruleset '%s'\n", call->interface, qe->skill_ruleset);
+		--*busies;
+		return 0;
+	}
+
 	if (use_weight && compare_weight(qe->parent, call->member)) {
 		ast_debug(1, "Priority queue delaying call to %s:%s\n",
 			qe->parent->name, call->interface);
@@ -4342,7 +4489,7 @@ static int ring_entry(struct queue_ent *
 	RAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);
 
 	/* on entry here, we know that tmp->chan == NULL */
-	if (!can_ring_entry(qe, tmp)) {
+	if (!can_ring_entry(qe, tmp, busies)) {
 		tmp->stillgoing = 0;
 		++*busies;
 		return 0;
@@ -5321,14 +5468,14 @@ static int is_our_turn(struct queue_ent
 	/* This needs a lock. How many members are available to be served? */
 	ao2_lock(qe->parent);
 
-	avl = num_available_members(qe->parent);
+	avl = num_available_members(qe->parent, qe);
 
 	ch = qe->parent->head;
 
 	ast_debug(1, "There %s %d available %s.\n", avl != 1 ? "are" : "is", avl, avl != 1 ? "members" : "member");
 
 	while ((idx < avl) && (ch) && (ch != qe)) {
-		if (!ch->pending) {
+		if (!ch->pending && ch->vqueue == qe->vqueue) {
 			idx++;
 		}
 		ch = ch->next;
@@ -5445,7 +5592,7 @@ static int wait_our_turn(struct queue_en
 		if (qe->parent->leavewhenempty) {
 			int status = 0;
 
-			if ((status = get_member_status(qe->parent, qe->max_penalty, qe->min_penalty, qe->parent->leavewhenempty, 0))) {
+			if ((status = get_member_status(qe->parent, qe->max_penalty, qe->min_penalty, qe->parent->leavewhenempty, 0, qe))) {
 				*reason = QUEUE_LEAVEEMPTY;
 				ast_queue_log(qe->parent->name, ast_channel_uniqueid(qe->chan), "NONE", "EXITEMPTY", "%d|%d|%ld", qe->pos, qe->opos, (long) (time(NULL) - qe->start));
 				leave_queue(qe);
@@ -5495,6 +5642,13 @@ static int wait_our_turn(struct queue_en
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
+
+		if (qe->skills_next_check && (time(NULL) >= qe->skills_next_check)) {
+			res = select_members_from_skills(qe);
+			if (res == -1) {
+				break;
+			}
+		}
 	}
 
 	return res;
@@ -6727,6 +6881,7 @@ static int try_calling(struct queue_ent
 		member = lpeer->member;
 		/* Increment the refcount for this member, since we're going to be using it for awhile in here. */
 		ao2_ref(member, 1);
+		recalc_member_holdtime(member, (now - qe->start));
 		hangupcalls(qe, outgoing, peer, qe->cancel_answered_elsewhere);
 		outgoing = NULL;
 		if (announce || qe->parent->reportholdtime || qe->parent->memberdelay) {
@@ -7058,7 +7213,7 @@ static struct member *interface_exists(s
 
 /*! \brief Dump all members in a specific queue to the database
  * \code
- * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>[|...]
+ * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<skills>[|...]
  * \endcode
  */
 static void dump_queue_members(struct call_queue *pm_queue)
@@ -7084,13 +7239,14 @@ static void dump_queue_members(struct ca
 			continue;
 		}
 
-		ast_str_append(&value, 0, "%s%s;%d;%d;%s;%s;%s",
+		ast_str_append(&value, 0, "%s%s;%d;%d;%s;%s;%s;%s",
 			ast_str_strlen(value) ? "|" : "",
 			cur_member->interface,
 			cur_member->penalty,
 			cur_member->paused,
 			cur_member->membername,
 			cur_member->state_interface,
+			cur_member->skills,
 			cur_member->reason_paused);
 
 		ao2_ref(cur_member, -1);
@@ -7121,6 +7277,7 @@ static int remove_from_queue(const char
 		.name = queuename,
 	};
 	struct member *mem, tmpmem;
+	struct queue_ent* qe;
 	int res = RES_NOSUCHQUEUE;
 
 	ast_copy_string(tmpmem.interface, interface, sizeof(tmpmem.interface));
@@ -7140,13 +7297,20 @@ static int remove_from_queue(const char
 			queue_publish_member_blob(queue_member_removed_type(), queue_member_blob_create(q, mem));
 
 			member_remove_from_queue(q, mem);
+			update_queue_ent_skills_next_check(q);
+
+			/* Remove member from selection of each callers. */
+			for(qe = q->head; qe; qe = qe->next)
+				if (qe->mem_selection)
+					ao2_unlink(qe->mem_selection, mem);
+
 			ao2_ref(mem, -1);
 
 			if (queue_persistent_members) {
 				dump_queue_members(q);
 			}
 
-			if (!num_available_members(q)) {
+			if (!num_available_members(q, NULL)) {
 				ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -7168,7 +7332,7 @@ static int remove_from_queue(const char
  * \retval RES_EXISTS queue exists but no members
  * \retval RES_OUT_OF_MEMORY queue exists but not enough memory to create member
 */
-static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, const char *reason_paused)
+static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, const char *reason_paused, const char *skills)
 {
 	struct call_queue *q;
 	struct member *new_member, *old_member;
@@ -7182,16 +7346,17 @@ static int add_to_queue(const char *queu
 
 	ao2_lock(q);
 	if ((old_member = interface_exists(q, interface)) == NULL) {
-		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, q->ringinuse))) {
+		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, q->ringinuse, skills))) {
 			new_member->ringinuse = q->ringinuse;
 			new_member->dynamic = 1;
 			if (reason_paused) {
 				ast_copy_string(new_member->reason_paused, reason_paused, sizeof(new_member->reason_paused));
 			}
 			member_add_to_queue(q, new_member);
+			update_queue_ent_skills_next_check(q);
 			queue_publish_member_blob(queue_member_added_type(), queue_member_blob_create(q, new_member));
 
-			if (is_member_available(q, new_member)) {
+			if (is_member_available(q, new_member, NULL)) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -7277,16 +7442,17 @@ static void set_queue_member_pause(struc
 		dump_queue_members(q);
 	}
 
-	if (is_member_available(q, mem)) {
+	if (is_member_available(q, mem, NULL)) {
 		ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE,
 			"Queue:%s_avail", q->name);
-	} else if (!num_available_members(q)) {
+	} else if (!num_available_members(q, NULL)) {
 		ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,
 			"Queue:%s_avail", q->name);
 	}
 
 	ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"),
 		"%s", S_OR(reason, ""));
+	update_queue_ent_skills_next_check(q);
 
 	publish_queue_member_pause(q, mem, reason);
 }
@@ -7539,6 +7705,7 @@ static void reload_queue_members(void)
 	char *member;
 	char *interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	char *state_interface;
 	char *penalty_tok;
 	int penalty = 0;
@@ -7591,6 +7758,7 @@ static void reload_queue_members(void)
 			paused_tok = strsep(&member, ";");
 			membername = strsep(&member, ";");
 			state_interface = strsep(&member, ";");
+			skills = strsep(&member, ";");
 			reason_paused = strsep(&member, ";");
 
 			if (!penalty_tok) {
@@ -7616,7 +7784,7 @@ static void reload_queue_members(void)
 			ast_debug(1, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d ReasonPause: %s\n",
 			              queue_name, interface, membername, penalty, paused, reason_paused);
 
-			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, reason_paused) == RES_OUTOFMEMORY) {
+			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, reason_paused, skills) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
 			}
@@ -7786,11 +7954,12 @@ static int aqm_exec(struct ast_channel *
 		AST_APP_ARG(options);
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
+		AST_APP_ARG(skills);
 	);
 	int penalty = 0;
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[,interface[,penalty[,options[,membername[,stateinterface]]]]])\n");
+		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[,interface[,penalty[,options[,membername[,stateinterface[,skills]]]]]])\n");
 		return -1;
 	}
 
@@ -7813,7 +7982,7 @@ static int aqm_exec(struct ast_channel *
 		}
 	}
 
-	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, NULL)) {
+	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, NULL, args.skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(args.membername) || !log_membername_as_agent) {
 			ast_queue_log(args.queuename, ast_channel_uniqueid(chan), args.interface, "ADDMEMBER", "%s", "");
@@ -7946,6 +8115,7 @@ static int queue_exec(struct ast_channel
 		AST_APP_ARG(gosub);
 		AST_APP_ARG(rule);
 		AST_APP_ARG(position);
+		AST_APP_ARG(skill_ruleset);
 	);
 	/* Our queue entry */
 	struct queue_ent qe = { 0 };
@@ -7954,7 +8124,7 @@ static int queue_exec(struct ast_channel
 	int max_forwards;
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "Queue requires an argument: queuename[,options[,URL[,announceoverride[,timeout[,agi[,macro[,gosub[,rule[,position]]]]]]]]]\n");
+		ast_log(LOG_WARNING, "Queue requires an argument: queuename[,options[,URL[,announceoverride[,timeout[,agi[,macro[,gosub[,rule[,position[,skill_ruleset]]]]]]]]]]\n");
 		return -1;
 	}
 
@@ -8068,6 +8238,9 @@ static int queue_exec(struct ast_channel
 	qe.prio = prio;
 	qe.max_penalty = max_penalty;
 	qe.min_penalty = min_penalty;
+	if (!ast_strlen_zero(args.skill_ruleset)) {
+		ast_copy_string(qe.skill_ruleset, args.skill_ruleset, sizeof(qe.skill_ruleset));
+	}
 	qe.last_pos_said = 0;
 	qe.last_pos = 0;
 	qe.last_periodic_announce_time = time(NULL);
@@ -8093,6 +8266,18 @@ check_turns:
 		ast_moh_start(chan, qe.moh, NULL);
 	}
 
+	switch (select_members_from_skills(&qe)) {
+	case 1:
+		if (!qe.parent->joinempty || !get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->joinempty, 0, &qe))
+			break;
+		reason = QUEUE_JOINEMPTY;
+	case -1:
+		goto stop;
+		break;
+	default:
+		break;
+	}
+
 	/* This is the wait loop for callers 2 through maxlen */
 	res = wait_our_turn(&qe, ringing, &reason);
 	if (res) {
@@ -8155,7 +8340,7 @@ check_turns:
 
 		if (qe.parent->leavewhenempty) {
 			int status = 0;
-			if ((status = get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->leavewhenempty, 0))) {
+			if ((status = get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->leavewhenempty, 0, &qe))) {
 				record_abandoned(&qe);
 				reason = QUEUE_LEAVEEMPTY;
 				ast_queue_log(args.queuename, ast_channel_uniqueid(chan), "NONE", "EXITEMPTY", "%d|%d|%ld", qe.pos, qe.opos, (long)(time(NULL) - qe.start));
@@ -8239,6 +8424,16 @@ stop:
 	if (reason != QUEUE_UNKNOWN)
 		set_queue_result(chan, reason);
 
+	if (qe.mem_selection) {
+		ao2_ref(qe.mem_selection, -1);
+	}
+
+	if (qe.vqueue && ao2_ref(qe.vqueue, -1) == 1 && qe.parent) {
+		/* unref vqueue, and if nobody has reference to vqueue except
+		 * the vqueues list, destroy the vqueue object by removing it
+		 * from list. */
+		ao2_unlink(qe.parent->vqueues, qe.vqueue);
+	}
 	/*
 	 * every queue_ent is given a reference to it's parent
 	 * call_queue when it joins the queue.  This ref must be taken
@@ -8899,6 +9094,121 @@ static int reload_queue_rules(int reload
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
+static int reload_queue_skills(int reload)
+{
+	struct ast_config *cfg;
+	char *cat = NULL, *tmp;
+	struct ast_variable *var;
+	struct skills_group *skgrp;
+	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
+
+	if (!(cfg = ast_config_load("queueskills.conf", config_flags))) {
+		ast_log(LOG_NOTICE, "No skills groups config file (queueskills.conf), so no call queues skills\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
+		ast_log(LOG_NOTICE, "queueskills.conf has not changed since it was last loaded. Not taking any action.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_ERROR, "Config file queueskills.conf is in an invalid format.  Aborting.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	}
+	AST_LIST_LOCK(&skills_groups);
+
+	/* Clear current skills */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skills_groups, skgrp, entry) {
+		AST_LIST_REMOVE_CURRENT(entry);
+		ao2_ref(skgrp, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		skgrp = ao2_alloc(sizeof(*skgrp), destroy_skills_group);
+
+		if (!skgrp) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for skills group");
+			break;
+		}
+		ast_copy_string(skgrp->name, cat, sizeof(skgrp->name));
+		skgrp->skills = ao2_container_alloc(37, NULL, NULL);
+
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill* sk;
+			sk = ao2_alloc(sizeof(*sk), NULL);
+			if (!sk) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a skill");
+				break;
+			}
+			ast_copy_string(sk->name, var->name, sizeof(sk->name));
+			tmp = ast_skip_blanks(var->value);
+			sk->weight = atoi(tmp);
+
+			ao2_link(skgrp->skills, sk);
+			ao2_ref(sk, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skills_groups, skgrp, entry);
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	ast_config_destroy(cfg);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int reload_queue_skill_rules(int reload)
+{
+	struct ast_config *cfg;
+	struct ast_variable *var;
+	struct skill_ruleset *ruleset;
+	char *cat = NULL;
+	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
+
+	if (!(cfg = ast_config_load("queueskillrules.conf", config_flags))) {
+		ast_log(LOG_NOTICE, "No rules config file (queueskillrules.conf), so no call queues rules\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
+		ast_log(LOG_NOTICE, "queueskillsrules.conf has not changed since it was last loaded. Not taking any action.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_ERROR, "Config file queueskillsrules.conf is in an invalid format.  Aborting.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	}
+	AST_LIST_LOCK(&skill_rulesets);
+
+	/* Clear current skill_rulesets */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skill_rulesets, ruleset, entry) {
+		AST_LIST_REMOVE_CURRENT(entry);
+		ao2_ref(ruleset, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		ruleset = ao2_alloc(sizeof(*ruleset), destroy_skill_ruleset);
+		if (!ruleset) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for a ruleset.");
+			break;
+		}
+		ast_copy_string(ruleset->name, cat, sizeof(ruleset->name));
+		ruleset->rules = ao2_container_alloc(37, NULL, NULL);
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill_rule *r = ao2_alloc(sizeof(*r), destroy_skill_rule);
+			if (!r) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a rule.");
+				break;
+			}
+			parse_skill_rule(r, var->value);
+
+			/* check if this rule is empty. */
+			if (r->cond)
+				ao2_link(ruleset->rules, r);
+			ao2_ref(r, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skill_rulesets, ruleset, entry);
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	ast_config_destroy(cfg);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
 /*! Set the global queue parameters as defined in the "general" section of queues.conf */
 static void queue_set_global_params(struct ast_config *cfg)
 {
@@ -8944,7 +9254,7 @@ static void queue_set_global_params(stru
  */
 static void reload_single_member(const char *memberdata, struct call_queue *q)
 {
-	char *membername, *interface, *state_interface, *tmp;
+	char *membername, *interface, *state_interface, *skills = NULL, *tmp;
 	char *parse;
 	struct member *cur, *newm;
 	struct member tmpmem;
@@ -8956,6 +9266,7 @@ static void reload_single_member(const c
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(ringinuse);
+		AST_APP_ARG(skills);
 	);
 
 	if (ast_strlen_zero(memberdata)) {
@@ -9010,11 +9321,15 @@ static void reload_single_member(const c
 		ringinuse = q->ringinuse;
 	}
 
+	if (!ast_strlen_zero(args.skills)) {
+		skills = ast_skip_blanks(args.skills);
+	}
+
 	/* Find the old position in the list */
 	ast_copy_string(tmpmem.interface, interface, sizeof(tmpmem.interface));
 	cur = ao2_find(q->members, &tmpmem, OBJ_POINTER);
 
-	if ((newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, ringinuse))) {
+	if ((newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, ringinuse, skills))) {
 		if (cur) {
 			/* Round Robin Queue Position must be copied if this is replacing an existing member */
 			ao2_lock(q->members);
@@ -9029,6 +9344,7 @@ static void reload_single_member(const c
 		ao2_ref(newm, -1);
 	}
 	newm = NULL;
+	update_queue_ent_skills_next_check(q);
 
 	if (cur) {
 		ao2_ref(cur, -1);
@@ -9300,6 +9616,12 @@ static int reload_handler(int reload, st
 	if (ast_test_flag(mask, QUEUE_RELOAD_RULES)) {
 		res |= reload_queue_rules(reload);
 	}
+	if (ast_test_flag(mask, QUEUE_RELOAD_SKILLS)) {
+		res |= reload_queue_skills(reload);
+	}
+	if (ast_test_flag(mask, QUEUE_RELOAD_SKILL_RULES)) {
+		res |= reload_queue_skill_rules(reload);
+	}
 	if (ast_test_flag(mask, QUEUE_RESET_STATS)) {
 		res |= clear_stats(queuename);
 	}
@@ -9444,6 +9766,8 @@ static char *__queues_show(struct manses
 						mem->status == AST_DEVICE_UNAVAILABLE || mem->status == AST_DEVICE_UNKNOWN ?
 							COLOR_RED : COLOR_GREEN, COLOR_BLACK),
 						ast_devstate2str(mem->status), ast_term_reset());
+				if (!ast_strlen_zero(mem->skills))
+					ast_str_append(&out, 0, " (skills: %s)", mem->skills);
 				if (mem->calls) {
 					ast_str_append(&out, 0, " has taken %d calls (last was %ld secs ago)",
 						mem->calls, (long) (time(NULL) - mem->lastcall));
@@ -9461,8 +9785,32 @@ static char *__queues_show(struct manses
 			struct queue_ent *qe;
 			int pos = 1;
 
+			if (q->vqueues) {
+				struct virtual_queue *vqueue;
+				struct ao2_iterator iter;
+				iter = ao2_iterator_init(q->vqueues, 0);
+				while ((vqueue = ao2_iterator_next(&iter)))
+				{
+					pos = 1;
+					ast_str_set(&out, 0, "   Virtual queue %s: ", vqueue->id);
+					do_print(s, fd, ast_str_buffer(out));
+					for (qe = q->head; qe; qe = qe->next) {
+						if (qe->vqueue != vqueue)
+							continue;
+						ast_str_set(&out, 0, "      %d. %s (wait: %ld:%2.2ld, prio: %d)",
+							pos++, ast_channel_name(qe->chan), (long) (now - qe->start) / 60,
+							(long) (now - qe->start) % 60, qe->prio);
+						do_print(s, fd, ast_str_buffer(out));
+					}
+					ao2_ref(vqueue, -1);
+				}
+				ao2_iterator_destroy(&iter);
+			}
+
 			do_print(s, fd, "   Callers: ");
 			for (qe = q->head; qe; qe = qe->next) {
+				if (qe->vqueue)
+					continue;
 				ast_str_set(&out, 0, "      %d. %s (wait: %ld:%2.2ld, prio: %d)",
 					pos++, ast_channel_name(qe->chan), (long) (now - qe->start) / 60,
 					(long) (now - qe->start) % 60, qe->prio);
@@ -9818,11 +10166,12 @@ static int manager_queues_status(struct
 						"Status: %d\r\n"
 						"Paused: %d\r\n"
 						"PausedReason: %s\r\n"
+						"Skills: %s\r\n"
 						"%s"
 						"\r\n",
 						q->name, mem->membername, mem->interface, mem->state_interface, mem->dynamic ? "dynamic" : "static",
 						mem->penalty, mem->calls, (int)mem->lastcall, (int)mem->lastpause, mem->in_call, mem->status,
-						mem->paused, mem->reason_paused, idText);
+						mem->paused, mem->reason_paused, mem->skills, idText);
 					++q_items;
 				}
 				ao2_ref(mem, -1);
@@ -9866,7 +10215,7 @@ static int manager_queues_status(struct
 
 static int manager_add_queue_member(struct mansession *s, const struct message *m)
 {
-	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface;
+	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *skills;
 	int paused, penalty = 0;
 
 	queuename = astman_get_header(m, "Queue");
@@ -9875,6 +10224,7 @@ static int manager_add_queue_member(stru
 	paused_s = astman_get_header(m, "Paused");
 	membername = astman_get_header(m, "MemberName");
 	state_interface = astman_get_header(m, "StateInterface");
+	skills = astman_get_header(m, "Skills");
 
 	if (ast_strlen_zero(queuename)) {
 		astman_send_error(s, m, "'Queue' not specified.");
@@ -9898,7 +10248,7 @@ static int manager_add_queue_member(stru
 		paused = abs(ast_true(paused_s));
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, NULL)) {
+	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, NULL, skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(membername) || !log_membername_as_agent) {
 			ast_queue_log(queuename, "MANAGER", interface, "ADDMEMBER", "%s", paused ? "PAUSED" : "");
@@ -10029,6 +10379,14 @@ static int manager_queue_reload(struct m
 		ast_set_flag(&mask, QUEUE_RELOAD_RULES);
 		header_found = 1;
 	}
+	if (!strcasecmp(S_OR(astman_get_header(m, "Skills"), ""), "yes")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILLS);
+		header_found = 1;
+	}
+	if (!strcasecmp(S_OR(astman_get_header(m, "SkillRules"), ""), "yes")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILL_RULES);
+		header_found = 1;
+	}
 	if (!strcasecmp(S_OR(astman_get_header(m, "Parameters"), ""), "yes")) {
 		ast_set_flag(&mask, QUEUE_RELOAD_PARAMETERS);
 		header_found = 1;
@@ -10154,7 +10512,7 @@ static int manager_queue_member_penalty(
 
 static char *handle_queue_add_member(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const char *queuename, *interface, *membername = NULL, *state_interface = NULL;
+	const char *queuename, *interface, *membername = NULL, *state_interface = NULL, *skills = NULL;
 	int penalty;
 
 	switch ( cmd ) {
@@ -10168,7 +10526,7 @@ static char *handle_queue_add_member(str
 		return complete_queue_add_member(a->line, a->word, a->pos, a->n);
 	}
 
-	if ((a->argc != 6) && (a->argc != 8) && (a->argc != 10) && (a->argc != 12)) {
+	if ((a->argc != 6) && (a->argc != 8) && (a->argc != 10) && (a->argc != 12) && (a->argc != 14)) {
 		return CLI_SHOWUSAGE;
 	} else if (strcmp(a->argv[4], "to")) {
 		return CLI_SHOWUSAGE;
@@ -10178,6 +10536,8 @@ static char *handle_queue_add_member(str
 		return CLI_SHOWUSAGE;
 	} else if ((a->argc == 12) && strcmp(a->argv[10], "state_interface")) {
 		return CLI_SHOWUSAGE;
+	} else if ((a->argc == 14) && strcmp(a->argv[12], "skills")) {
+		return CLI_SHOWUSAGE;
 	}
 
 	queuename = a->argv[5];
@@ -10204,7 +10564,11 @@ static char *handle_queue_add_member(str
 		state_interface = a->argv[11];
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, NULL)) {
+	if (a->argc >= 14) {
+		skills = a->argv[13];
+	}
+
+	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, NULL, skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(membername) || !log_membername_as_agent) {
 			ast_queue_log(queuename, "CLI", interface, "ADDMEMBER", "%s", "");
@@ -10591,6 +10955,147 @@ static char *handle_queue_rule_show(stru
 	return CLI_SUCCESS;
 }
 
+static char *complete_queue_skills_groups(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	struct skills_group *skills;
+	int wordlen = strlen(word);
+	char *ret = NULL;
+	if (pos != 4) /* Wha? */ {
+		return NULL;
+	}
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!strncasecmp(word, skills->name, wordlen) && ++which > state) {
+			ret = ast_strdup(skills->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+
+	return ret;
+}
+
+static char *handle_queue_skills_groups(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	const char *name;
+	struct skills_group *skills;
+	struct skill *skill;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "queue show skills groups";
+		e->usage =
+		"Usage: queue show skills groups [groupname]\n"
+		"	Show the list of skills associated to the group name. If no\n"
+		"	groupname is specified, list all skill groups\n";
+		return NULL;
+	case CLI_GENERATE:
+		return complete_queue_skills_groups(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc != 3 && a->argc != 4 && a->argc != 5)
+		return CLI_SHOWUSAGE;
+
+	name = a->argc == 5 ? a->argv[4] : "";
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!name || !strcmp(skills->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+			if (name) {
+				ast_cli(a->fd, "Skill group '%s':\n", skills->name);
+			} else {
+				ast_cli(a->fd, "  - %-15s: ", skills->name);
+			}
+
+			while ((skill = ao2_iterator_next(&iter))) {
+				if (name) {
+					ast_cli(a->fd, "  - %-15s: %d\n", skill->name, skill->weight);
+				} else {
+					ast_cli(a->fd, "%s=%d ", skill->name, skill->weight);
+				}
+				ao2_ref(skill, -1);
+			}
+			ast_cli(a->fd, "\n");
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	return CLI_SUCCESS;
+}
+
+static char *complete_queue_skills_rules(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	struct skill_ruleset *rs;
+	int wordlen = strlen(word);
+	char *ret = NULL;
+	if (pos != 4) /* Wha? */ {
+		return NULL;
+	}
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!strncasecmp(word, rs->name, wordlen) && ++which > state) {
+			ret = ast_strdup(rs->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+
+	return ret;
+}
+
+static char *handle_queue_skills_rules(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	const char *name;
+	struct skill_ruleset *rs;
+	struct skill_rule *rule;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "queue show skills rules";
+		e->usage =
+		"Usage: queue show skills rules [rulename]\n"
+		"	Show the list of rules associated to the ruleset name. If no\n"
+		"	rulename is specified, list all rulesets\n";
+		return NULL;
+	case CLI_GENERATE:
+		return complete_queue_skills_rules(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc != 3 && a->argc != 4 && a->argc != 5)
+		return CLI_SHOWUSAGE;
+
+	name = a->argc == 5 ? a->argv[4] : "";
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!name || !strcmp(rs->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(rs->rules, 0);
+
+			ast_cli(a->fd, "Skill rules '%s':\n", rs->name);
+			while ((rule = ao2_iterator_next(&iter))) {
+				char *cond = display_operator(rule->cond);
+				if (rule->dcond) {
+					char *dcond = display_operator(rule->dcond);
+					ast_cli(a->fd, "  => [%s] %s\n", dcond, cond);
+					ast_free(dcond);
+				}
+				else
+					ast_cli(a->fd, "  => %s\n", cond);
+				ast_free(cond);
+				ao2_ref(rule, -1);
+			}
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	return CLI_SUCCESS;
+}
+
 static char *handle_queue_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct ast_flags mask = {QUEUE_RESET_STATS,};
@@ -10678,6 +11183,10 @@ static char *handle_queue_reload(struct
 		ast_set_flag(&mask, QUEUE_RELOAD_MEMBER);
 	} else if (!strcasecmp(a->argv[2], "parameters")) {
 		ast_set_flag(&mask, QUEUE_RELOAD_PARAMETERS);
+	} else if (!strcasecmp(a->argv[2], "skills")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILLS);
+	} else if (!strcasecmp(a->argv[2], "skillrules")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILL_RULES);
 	} else if (!strcasecmp(a->argv[2], "all")) {
 		ast_set_flag(&mask, AST_FLAGS_ALL);
 	}
@@ -10704,6 +11213,8 @@ static struct ast_cli_entry cli_queue[]
 	AST_CLI_DEFINE(handle_queue_set_member_ringinuse, "Set ringinuse for a channel of a specified queue"),
 	AST_CLI_DEFINE(handle_queue_reload, "Reload queues, members, queue rules, or parameters"),
 	AST_CLI_DEFINE(handle_queue_reset, "Reset statistics for a queue"),
+	AST_CLI_DEFINE(handle_queue_skills_groups, "Show the skills groups defined in queueskills.conf"),
+	AST_CLI_DEFINE(handle_queue_skills_rules, "Show the skills rules defined in queueskillrules.conf"),
 };
 
 /* struct call_queue astdata mapping. */
@@ -10765,6 +11276,7 @@ static struct ast_cli_entry cli_queue[]
 	MEMBER(call_queue, rrpos, AST_DATA_INTEGER)			\
 	MEMBER(call_queue, memberdelay, AST_DATA_INTEGER)		\
 	MEMBER(call_queue, autofill, AST_DATA_INTEGER)			\
+	MEMBER(call_queue, vqueues, AST_DATA_CONTAINER)			\
 	MEMBER(call_queue, members, AST_DATA_CONTAINER)
 
 AST_DATA_STRUCTURE(call_queue, DATA_EXPORT_CALL_QUEUE);
@@ -10774,6 +11286,7 @@ AST_DATA_STRUCTURE(call_queue, DATA_EXPO
 	MEMBER(member, interface, AST_DATA_STRING)			\
 	MEMBER(member, state_interface, AST_DATA_STRING)		\
 	MEMBER(member, membername, AST_DATA_STRING)			\
+	MEMBER(member, skills, AST_DATA_STRING)				\
 	MEMBER(member, penalty, AST_DATA_INTEGER)			\
 	MEMBER(member, calls, AST_DATA_INTEGER)				\
 	MEMBER(member, dynamic, AST_DATA_INTEGER)			\
@@ -10803,6 +11316,7 @@ AST_DATA_STRUCTURE(member, DATA_EXPORT_M
 	MEMBER(queue_ent, min_penalty, AST_DATA_INTEGER)			\
 	MEMBER(queue_ent, linpos, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, linwrapped, AST_DATA_INTEGER)				\
+	MEMBER(queue_ent, skill_ruleset, AST_DATA_STRING)			\
 	MEMBER(queue_ent, start, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, expire, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, cancel_answered_elsewhere, AST_DATA_INTEGER)
Index: asterisk-14.4.0-rc1/configs/samples/queueskillrules.conf.sample
===================================================================
--- /dev/null
+++ asterisk-14.4.0-rc1/configs/samples/queueskillrules.conf.sample
@@ -0,0 +1,63 @@
+; This file describes skill routing rules. The Queue() application can get the
+; 'skill_ruleset' argument which is the name of one skill routing ruleset. If
+; set, a selection of queue members is defined by running these rules on each
+; member, based on skills set (see the queueskills.conf file).
+;
+; A ruleset is a list of rules. Each rule has two parts:
+;     - the first part is a dynamical condition. If its evaluation is false, the
+;       next rule is tried;
+;     - the second part is tested against queue member's skills, to define a
+;       selection.
+;
+; Operators:
+; ----------
+;
+; You can define these rules with some comparison and logical operators:
+;      operand1 ! operand2  (is not equal)
+;      operand1 = operand2  (is equal)
+;      operand1 > operand2  (is greater than)
+;      operand1 < operand2  (is lesser than)
+;      operand1 & operand2  (both are true)
+;      operand1 | operand2  (at least one of them are true)
+;
+; '!' is the operator with the higher priority, and '|' the one with the lower
+; priority. You can use brackets '()' to overload operator priorities.
+;
+; Dynamical part:
+; ---------------
+; The first part is evaluated after create a selection of queue members with
+; the second part, and determine if we keep this rule or if we switch to the
+; next one.
+;
+; On this part, these variables can be used:
+;     EWT (Estimated Waiting Time)      The waiting time estimated for the
+;                                       current selection of members
+;     WT  (Waiting time)                The time that caller has been waited
+;
+; Skills part:
+; ------------
+; This second part is evaluated against every queue member's skills, to know
+; if it is selected or not.
+;
+; Variables are skills names, which you can check with below operators. You can
+; also use meta-variables, started with a '$', to substitute them with data set
+; on the Queue() call. For example, if you call Queue() with the skill rouleset
+; argument equal to:
+;      tech(os=linux)
+; every $os occurrence will be replaced to 'linux'.
+;
+; Examples:
+; ---------
+;
+; [tech]
+; rule => WT < 60, technic & ($os > 29 & $lang > 39 | $os > 39 & $lang > 19)
+; rule => WT < 120, technic & ($os > 19 & $lang > 39 | $os > 29 & $lang > 19)
+; rule => WT < 3600, technic & $os > 10 & $lang > 19
+; rule => technic
+;
+; [client-crappy]
+; rule => technic = 0 & (sympathy > 20 | linux > 10 & windows > 10)
+;
+; [client-cool]
+; rule => EWT < 120, technic = 0 & (sympathy > 60)
+; rule => technic = 0
Index: asterisk-14.4.0-rc1/configs/samples/queueskills.conf.sample
===================================================================
--- /dev/null
+++ asterisk-14.4.0-rc1/configs/samples/queueskills.conf.sample
@@ -0,0 +1,46 @@
+; Describe skills groups here to assign them to queue members. You can set
+; weight to each skills. It'll be used by skill rules to know if a queue member
+; can answer to a call.
+; See the queueskillrules.conf to get more information about these rules.
+;
+; Examples:
+;
+; [linux1]
+; technic = 1
+; linux = 50
+; windows = 10
+; french = 50
+; english = 10
+;
+; [linux2]
+; technic = 1
+; linux = 30
+; windows = 20
+; french = 50
+; english = 50
+;
+; [windows1]
+; technic = 1
+; linux = 10
+; windows = 50
+; french = 30
+; english = 30
+;
+; [windows2]
+; technic = 1
+; linux = 20
+; windows = 30
+; french = 40
+; english = 10
+;
+; [commercial1]
+; technic = 0
+; linux = 10
+; windows = 20
+; sympathy = 100
+;
+; [commercial2]
+; technic = 0
+; linux = 0
+; windows = 20
+; sympathy = 50
