Index: asterisk-14.4.0/include/asterisk/channel.h
===================================================================
--- asterisk-14.4.0.orig/include/asterisk/channel.h
+++ asterisk-14.4.0/include/asterisk/channel.h
@@ -4736,4 +4736,8 @@ enum ast_channel_error ast_channel_errno
  */
 int ast_channel_get_intercept_mode(void);
 
+void ast_dual_redirect_set(struct ast_channel* chan);
+void ast_dual_redirect_unset(struct ast_channel* chan);
+int ast_dual_redirect_is_set(struct ast_channel* chan);
+
 #endif /* _ASTERISK_CHANNEL_H */
Index: asterisk-14.4.0/main/bridge_channel.c
===================================================================
--- asterisk-14.4.0.orig/main/bridge_channel.c
+++ asterisk-14.4.0/main/bridge_channel.c
@@ -2815,7 +2815,7 @@ int bridge_channel_internal_join(struct
 	 * Must be done while "still in the bridge" for ast_async_goto()
 	 * to work right.
 	 */
-	while (ast_test_flag(ast_channel_flags(bridge_channel->chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT)) {
+	while (ast_dual_redirect_is_set(bridge_channel->chan)) {
 		sched_yield();
 	}
 	ast_channel_lock(bridge_channel->chan);
Index: asterisk-14.4.0/main/channel.c
===================================================================
--- asterisk-14.4.0.orig/main/channel.c
+++ asterisk-14.4.0/main/channel.c
@@ -11046,3 +11046,56 @@ ast_mutex_t *ast_channels_get_mutex(void
 {
 	return ao2_object_get_lockaddr(channels);
 }
+
+struct dual_redirect_sync {
+	char unique_id[AST_MAX_UNIQUEID];
+	AST_LIST_ENTRY(dual_redirect_sync) list;
+};
+
+static AST_RWLIST_HEAD_STATIC(pending_dual_redirects, dual_redirect_sync);
+
+void ast_dual_redirect_set(struct ast_channel* chan)
+{
+	struct dual_redirect_sync *dual_redirect = ast_malloc(sizeof(struct dual_redirect_sync));
+	memset(dual_redirect, 0, sizeof(*dual_redirect));
+	ast_copy_string(dual_redirect->unique_id, ast_channel_uniqueid(chan), AST_MAX_UNIQUEID);
+	AST_RWLIST_WRLOCK(&pending_dual_redirects);
+	AST_RWLIST_INSERT_TAIL(&pending_dual_redirects, dual_redirect, list);
+	AST_RWLIST_UNLOCK(&pending_dual_redirects);
+	ast_debug(2, "dual redirect set on %s\n", ast_channel_uniqueid(chan));
+}
+
+void ast_dual_redirect_unset(struct ast_channel* chan)
+{
+	struct dual_redirect_sync *iter;
+
+	AST_RWLIST_WRLOCK(&pending_dual_redirects);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&pending_dual_redirects, iter, list) {
+		if (!strcmp(iter->unique_id, ast_channel_uniqueid(chan))) {
+			AST_LIST_REMOVE_CURRENT(list);
+			ast_free(iter);
+			ast_debug(2, "dual redirect unset on %s\n", ast_channel_uniqueid(chan));
+			break;
+		}
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&pending_dual_redirects);
+}
+
+int ast_dual_redirect_is_set(struct ast_channel* chan)
+{
+	struct dual_redirect_sync *iter;
+	int found = 0;
+
+	AST_RWLIST_WRLOCK(&pending_dual_redirects);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&pending_dual_redirects, iter, list) {
+		if (!strcmp(iter->unique_id, ast_channel_uniqueid(chan))) {
+			found = 1;
+			break;
+		}
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&pending_dual_redirects);
+
+	return found;
+}
Index: asterisk-14.4.0/main/manager.c
===================================================================
--- asterisk-14.4.0.orig/main/manager.c
+++ asterisk-14.4.0/main/manager.c
@@ -4821,19 +4821,15 @@ static int action_redirect(struct manses
 	}
 
 	/* Dual channel redirect in progress. */
-	ast_channel_lock(chan);
 	if (ast_channel_is_bridged(chan)) {
-		ast_set_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
+		ast_dual_redirect_set(chan);
 		chan1_wait = 1;
 	}
-	ast_channel_unlock(chan);
 
-	ast_channel_lock(chan2);
 	if (ast_channel_is_bridged(chan2)) {
-		ast_set_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
+		ast_dual_redirect_set(chan2);
 		chan2_wait = 1;
 	}
-	ast_channel_unlock(chan2);
 
 	res = ast_async_goto(chan, context, exten, pi);
 	if (!res) {
@@ -4853,14 +4849,10 @@ static int action_redirect(struct manses
 
 	/* Release the bridge wait. */
 	if (chan1_wait) {
-		ast_channel_lock(chan);
-		ast_clear_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
-		ast_channel_unlock(chan);
+		ast_dual_redirect_unset(chan);
 	}
 	if (chan2_wait) {
-		ast_channel_lock(chan2);
-		ast_clear_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
-		ast_channel_unlock(chan2);
+		ast_dual_redirect_unset(chan2);
 	}
 
 	chan2 = ast_channel_unref(chan2);
